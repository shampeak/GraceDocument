# 防御性编程
> 防御性编程
## 参考网址

[link1](http://kb.cnblogs.com/page/140426/)
[link2](http://www.cnblogs.com/bakari/archive/2012/08/27/2658215.html)

## 基本概念
防御性编程（Defensive programming）是防御式设计的一种具体体现，它是为了保证，对程序的不可预见的使用，不会造成程序功能上的损坏。它可以被看作是为了减少或消除墨菲定律效力的想法。防御式编程主要用于可能被滥用，恶作剧或无意地造成灾难性影响的程序上。来自[百度百科](http://baike.baidu.com/link?url=QxVByMCkQAijS5LR_AQU-wY5IMLjrCL_TBUZ8TbH2ZG-MirPHBPfWME1tbIcG5bjhcXl6n8Q4_Va6UcyhNVyXa)

每当程序员突然遇到某个bug并不知道怎么改的时候，他们会添加一些“防御性代码”来使编码更安全并且更容易找到问题的原因。有时这样做可以消除错误。他们加强了数据的有效性验证——检验输入框、输出框和返回值的内容；审查并改善错误处理——可能会添加一些针对于出现“异常”情况的验证代码；添加一些有用的日志和诊断。换句话说，就是最好一开始就应该出现在那儿的代码。
> 防御性编程的关键在于未雨绸缪，防患于未然。
> —— Steve McConnell, 《Code Complete》(中文版：《代码大全》)
   
   防御性编程是一种编程习惯，是指预见在什么地方可能会出现问题，然后创建一个环境来测试错误，当预见的问题出现的时候通知你，并执行一个你指定的损害控制动作，如停止程序执行，将用户重指向到一个备份的服务器，或者开启一个你可以用来诊断问题的调试信息。这些防御性编程环境通常的构造方法有：==添加声明到代码中，执行按契约进行设计，开发软件防御防火墙，或者简单添加
## 优势
用来验证用户输入的代码==。
 应用防御性编程技术，你可以侦测到可能被忽略的错误，防止可能会导致灾难性后果的“小毛病”的出现，在时间的运行过程中为你节约大量的调试时间。 防御性编程使我们可以尽早发现较小的问题，而不是等到它们发展成大的灾难的时候才发现。你常常可以看到“职业”的开发人员不假思索飞快地编写着代码。

他们开发软件的过程可能是这样的：

![](http://pic002.cnblogs.com/images/2012/431521/2012082710080991.jpg)
 
 他们不断地受到那些从未有时间验证的错误的打击。这很难说是现代软件工程的进步，但它却不断地发生着。防御性编程帮助我们从一开始就编写正确的软件，而不再需要经历“编写－尝试－编写－尝试……”的循环过程。

防御性编程的软件开发过程变成：
![](http://pic002.cnblogs.com/images/2012/431521/2012082713280383.jpg)
## 基本原则
　在Steve McConnell的经典编程书籍，《Code Complete》里的几个简单章节里讲到了防御性编程的几条基本规则：

1. 保护你的代码不要受“外界”的无效数据影响，“外界”影响有很多种情况。外部系统的数据，某个用户的操作或模型/组件外面的数据。任何在控制范围之外的东西都是危险的，而任何在控制范围之内的都是安全的，所以要设立“安全区”。在安全区域的代码会验证所有的输入数据：检查所有输入参数的类型，长度和取值范围。可以通过双击来检测有没有溢出。
2. 当检验到了错误的数据后，可以考虑如何处理它。防御性编程并不意味着要忍受错误或是避开错误。它意味着要从健壮性(如果遇到你能处理的问题时能保持程序运行)和正确性（不会返回错误的结果）之间权衡最合适的处理方式。可以选择一种策略来处理错误的数据：报错并立刻停止程序(快速结束)，返回一个替代的数据值，等等，总之要确保这个策略是明显一致的。
3. 不要以为在代码外进行函数调用和方法调用会像你所想的那般顺利。你要明白这一点，并在外部的API和库里测试你的错误处理。
4. 在开发和测试的情况下，可以使用断言来假设某种“可能出现”的条件并特别显示出来。这对于需要不同的人在各个时间进行维护的高可靠性大型系统来说尤其重要。
5. 添加诊断代码可以智能记录并追踪代码，它可以解释运行时当前的情况，尤其在遇到某个问题时它的帮助会更大。
6. 错误处理需要标准化。要考虑遇到“一般错误”、“预料中错误”和警告时的各种处理方式，决定好之后就不要再改了。
7. 只有在你需要的时候，并且你对编程语言的异常处理极为熟悉才可以使用异常处理。

> 在一般的错误处理中使用异常处理的程序会引起可读性和可维护性的代码问题。
>     ——《The Pragmatic Programmer》（中文版：《程序员修炼之道：从小工到专家》）
> 
　　我想再加两条规则。一个是Michael Nygard的Release It!中提到的，绝对不要去不断地等待某个外部的调用，尤其是远程调用。如果什么地方出现问题了，时间会非常漫长。使用暂停/重试的逻辑方法和他的Circuit Breaker稳定方案可以解决远程问题。

　　另一个规则是，对于像C和C++的语言，防御性编程也包括使用安全函数调用来避免缓冲区溢出和其他常见的代码错误。
　　
## 防御性编程的技巧


### 1、通过采用良好的编程风格，来防范大多数编码错误

如选用有意义的变量名，或者审慎地使用括号，都可以使编码变得更加清晰了，并减少缺陷出现的可能性。在投入到编码工作之前，先考虑大体的设计方案，这也很关键。

### 2、不要仓促地写代码

在写每一行时都要三思而后行。可能会出现什么样的错误？你是否已经考虑了所有可能出现的逻辑分支？放慢速度，有条不紊的编程虽然看上去很平凡，但这的确是减少缺陷的好办法。

### 3、不要相信任何人

不要相信任何人毫无疑问，任何人（包括你自己）都可能把缺陷引到你的逻辑程序当中，用怀疑的眼光审视所有的输入和所有的结果，直到你能证明它们是正确的为止。

下面这些情况可能是给你带来麻烦的原因：

真正的用户意外地提供了假的输入，或者错误地操作了程序；恶意的用户，故意造成不好的程序行为；客户端代码使用的参数调用了你的函数，或者提供了不一致的输入；运行环境没有为程序提供足够的服务；外部程序库运行失误，不遵从你所依赖的接口协议；

### 4、编码的目标是清晰，不只是简洁

简单就是一种美，不要让你的代码过于复杂。

### 5、不要让任何人做让他们不该做的修补工作

将所有变量保持在尽可能小的范围内。不到万不得已，不要声明全局变量。如果变量可以声明为函数内的局部变量，就不要再文件范围上声明。如果变量可以声明为循环体内的局部变量，就不要再函数范围上声明。

### 6、检查所有的返回值

如果一个函数返回一个值，它这样做肯定是有理由的。大多数难以察觉的错误都是因为程序员没有检查返回值而出现的。无论如何，都要在适当的级别上捕获和处理相应的异常。

### 7、审慎地处理内存（和其他宝贵的资源）

### 8 、使用安全的数据结构
如果你做不到，那么就安全地使用危险的数据结构。

最常见的安全隐患大概是由缓冲溢出引起的。缓冲溢出是由于不正确地使用固定大小的数据结构而造成的。如果你的代码在没有检查一个缓冲的大小之前就写入这个缓冲，那么写入的内容总是有可能会超过缓冲的末尾的。

这种情况很容易出现，如下面这一小段C语言代码所示：



```
char *unsafe_copy(const char *source)
 
 {
       char *buffer = new char[10];
       strcpy(buffer, source);
       return buffer;
 }
```
如果source中数据的长度超过10个字符，它的副本就会超出buffer所保留内存的末尾。随后，任何事都可能会发生。数据出错是最好情况下的结果——一些其他数据结构的内容会被覆盖。而在最坏的情况下，恶意用户会利用这个简单的错误，把可执行代码加入到程序堆栈中，并使用它来任意运行他自己的程序，从而劫持了计算机。这类缺陷常常被系统黑客所利用，后果极其严重。

避免由于这些隐患而受到攻击其实很简单：不要编写这样的糟糕代码！使用更安全的、不允许破坏程序的数据结构——使用类似C++的string类的托管缓冲。或者
对不安全的数据类型系统地使用安全的操作。通过把strcpy更换为有大小限制的字符串复制操作strncpy，就可以使上面的C代码段得到保护。



```
char *safer_copy(const char *source)
 {
       char *buffer = new char[10];
       strncpy(buffer, source, 10);
       return buffer;
 }
```
### 9、在声明的位置上初始化所有的变量

### 10、尽可能推迟一些声明变量

使变量的声明位置与使用它的位置尽量接近，从而防止它干扰代码的其他部分。不要再多个地方重用同一个临时变量，变量重用会使以后对代码重新完善的工作变得异常复杂。

### 11、审慎地进行强制转换

如果你真的想使用强制转换，就必须对之深思熟虑。你所告诉编译器的是：“忘记类型检查吧，我知道这个变量是什么，而你不知道。”你在类型系统中撕开了一个大洞，并直接穿越过去。这样做很不可靠。

### 12、其他

- 提供默认的行为
- 遵从语言的习惯
- 检查数值的上下限
- 正确设置常量

 
　　
## 看法
### 反对意见

防御性编程消耗了程序员和计算机的资源。

- 它降低了代码的效率；即使是很少的额外代码也需要一些额外的执行时间。对于一个函数或一个类，这也许还不要紧，但是如果一个系统由10万个函数组成，问题就变得严重了。

- 每种防御性的做法都需要一些额外的工作。为什么要做这些工作呢？你需要做的已经够多的了，不是吗？只要确保人们正确地使用你的代码就可以了。如果他们使用的方式不正确，那么任何问题也都是他们自己造成的。

### 支持意见

反驳很有说服力。

- 防御性编程可以节省大量的调试时间，使你可以去做更有意义的事情。还记得墨菲吗：凡是可能会被错误地使用的代码，一定会被错误地使用。

- 编写可以正确运行、只是速度有些慢的代码，要远远好过大多数时间都正常运行、但是有时候会崩溃的代码（显示器闪烁高亮彩色火花）。

- 我们可以设计一些在版本构建中物理移除的防御性代码，以解决性能问题。总之，我们这里所考虑的大部分防御性措施，并不具有任何明显的开销。

- 防御性编程避免了大量的安全性问题，这在现代软件开发中是一个重大的问题。避免这些问题可以带来很多好处。

由于市场要求软件的开发更加快速和廉价，我们就需要致力于实现这一目标的技术。不要跳过眼前的这些额外工作，它们可以防止将来的痛苦和项目延迟。

防御性编程有助于程序的安全性，可以防范诸如此类恶意的滥用。黑客和病毒制造者常常会利用那些不严谨的代码，以控制某个应用程序，然后实施他们蓄意的破坏计划。这对软件开发的现代世界而言，无疑是个严重的威胁；这个问题涉及到诸如生产效率、金钱和个人隐私等方方面面。

软件滥用者形形色色，从利用程序小缺陷的不守规则的用户，到想尽办法非法进入他人系统的职业黑客。有太多的程序员在不经意间为这些人留下了可随意通过的后门。随着网络化计算机的兴起，粗心大意所带来的后果变得愈来愈显著了。

许多大型软件开发公司终于意识到了这种威胁，开始认真思考这个问题，将时间和资源投入到严谨的防御性编码工作中。事实上，在受到恶意进攻之后才亡羊补牢是很困难的。


***@editor： siluzhou***